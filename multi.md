# Zero-Redundancy LLM Arbitration System Using Probabilistic Early Rejection and Reward-Guided Selection
Summary Statement Example for Your Patent or Paper
‚ÄúOur Zero-Redundancy LLM Arbitration System is a novel, highly efficient approach to selecting the best Large Language Model for classification tasks. By combining early model dropout based on easy examples with a reward-driven multi-armed bandit for dynamic input assignment, our system optimally balances accuracy and computational cost. The inclusion of an optional task-specific routing mechanism further enhances assignment precision. This architecture uniquely minimizes redundant evaluations, adapts in real time, and scales gracefully, establishing a new state-of-the-art for efficient LLM model selection.‚Äù


## Abstract

We introduce a novel arbitration system that efficiently selects the best-performing Large Language Models (LLMs) for classification, minimizing redundancy by:

- Using a fast early-rejection step on ‚Äúeasy‚Äù examples
- Employing a reward-driven multi-armed bandit algorithm to assign future examples to strong-performing models
- Optionally routing examples to specialized models using learned input features

This design significantly reduces computation from \( \mathcal{O}(N \times D) \) to approximately \( \mathcal{O}(N) + \mathcal{O}(D) \), making it viable for deployment in real-time, compute-constrained environments.

---

## 1. Background

Running all \( N \) LLMs on \( D \) examples incurs a cost of:

\[
\mathcal{O}(N \times D)
\]

Ensemble methods provide robustness but are computationally expensive and often redundant. Our approach reduces redundancy by early-dropping weak models and assigning examples intelligently using adaptive reward mechanisms.

---

## 2. Architecture Overview

The system proceeds in three distinct stages:

### Stage 1: Probabilistic Early Rejection (PER)

Let:

- \( \mathcal{E} = \{x_1, x_2, \ldots, x_k\} \) be a set of easy examples  
- \( M_i \) be the \( i \)-th model out of \( N \)  
- \( y_j \) be the true label for input \( x_j \)

We compute the accuracy of model \( M_i \) on the easy set:

\[
A_i = \frac{1}{k} \sum_{j=1}^{k} \mathbf{1}[M_i(x_j) = y_j]
\]

If:

\[
A_i < \tau
\]

where \( \tau \in (0, 1) \), model \( M_i \) is dropped from future consideration.

This filters out models that fail to classify trivial or low-entropy examples correctly.

---

### Stage 2: Reward-Guided Bandit Allocation (RGBA)

Remaining models (say \( M' \ll N \)) are modeled as arms in a contextual multi-armed bandit. At each time step \( t \), an input \( x_t \) is assigned to a model \( M_i \) based on a policy \( \pi(t) \).

Each model receives a reward defined as:

\[
r_i(t) = \alpha \cdot \mathbf{1}[M_i(x_t) = y_t] + \beta \cdot \mathrm{conf}(M_i(x_t))
\]

Where:

- \( \alpha, \beta \) are hyperparameters  
- \( \mathrm{conf}(M_i(x_t)) \in [0, 1] \) is model confidence  

The cumulative reward is:

\[
R_T = \sum_{t=1}^{T} r_{\pi(t)}(t)
\]

We update the value estimate of each model using:

\[
Q_i(t+1) = Q_i(t) + \eta \cdot \left(r_i(t) - Q_i(t)\right)
\]

Where:

- \( Q_i \) is the estimated value of model \( M_i \)  
- \( \eta \) is the learning rate  

---

### Stage 3 (Optional): Task-Specific Router (TSR)

Train a lightweight classifier \( R(x) \) using features \( \phi(x) \) (e.g., sentence embeddings) to route inputs to the most suitable model:

\[
R(x) = \arg\max_i \; P(M_i \mid \phi(x))
\]

Router models may include logistic regression, SVMs, or shallow neural networks.

---

## 3. Component Overview

| Component         | Description                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------------|
| EasySetSelector   | Selects low-entropy examples \( H(p(y|x)) < H_0 \)                                            |
| FailureDetector   | Removes models \( M_i \) with \( A_i < \tau \)                                               |
| BanditAllocator   | Selects models via reward-maximizing bandit policy                                           |
| RewardEngine      | Computes: \( r_i(t) = \alpha \cdot \text{accuracy} + \beta \cdot \text{confidence} \)       |
| ModelRouter (TSR) | Learns to route inputs via \( R(x) = \arg\max_i P(M_i \mid \phi(x)) \)                        |

---

## 4. Complexity Comparison

| Method           | Complexity                   |
|------------------|------------------------------|
| Traditional      | \( \mathcal{O}(N \times D) \) |
| This Method      | \( \mathcal{O}(k \times N) + \mathcal{O}(M' \times D') \), where \( k \ll D \), \( M' \ll N \) |

Net effective cost:  

\[
\mathcal{O}(N) + \mathcal{O}(D)
\]

---

## 5. Novelty & Inventive Step

- **Probabilistic Early Rejection:** dynamically filters weak models early based on easy samples.  
- **Bandit-Driven Selection:** incorporates model confidence and reward signals for efficient selection.  
- **Task-Specific Routing:** optional downstream router personalizes model assignment.

No prior art combines:

- Early rejection on easy samples,  
- Bandit-based selection using model confidence,  
- Task-aware dynamic routing.

---


Uniqueness and Novelty
1. Probabilistic Early Rejection Based on ‚ÄúEasy‚Äù Examples
Unlike existing ensemble or multi-model selection techniques that treat all data points equally, this system introduces a data-driven early rejection step using a carefully curated subset of "easy" examples.

This ensures models that fail on trivial or low-entropy cases are immediately discarded, saving computational resources upfront.

The dynamic threshold 
ùúè
œÑ is adaptive and learned, enabling flexible model pruning customized per deployment environment.

This pre-filtering concept based on example difficulty combined with model performance is a novel use in LLM arbitration.

2. Reward-Guided Multi-Armed Bandit Model Selection
While multi-armed bandits have been widely used in model selection and online learning, our system integrates:

Model confidence scores into the reward signal, not just accuracy, reflecting the certainty of predictions, which improves stability and decision granularity.

An adaptive learning rate mechanism that balances exploration and exploitation in selecting models per incoming example stream.

This fine-grained reward design with confidence-augmented feedback for model arbitration is unique in the LLM domain.

3. Dynamic Model Dropout Driven by Easy Example Performance
The novel integration of early rejection with bandit-based allocation enables dynamic dropout of underperforming models after the initial easy example evaluation, which contrasts with static ensembling or manual selection in prior art.

The approach reduces the model pool without multiple passes over the entire dataset.

This efficiency gain is crucial for large-scale LLM systems, where each model evaluation is costly.

4. Optional Task-Specific Router for Input-Conditional Model Assignment
The introduction of a lightweight input router trained on learned input features to map examples to the most competent model introduces:

Fine-grained, input-aware specialization beyond simple global model ranking.

A modular architecture allowing plug-and-play of any classification routing mechanism, including logistic regression, SVM, or shallow neural nets.

This hybrid combination of bandit-based arbitration with routing adds flexibility and further efficiency.

5. Computational Efficiency and Scalability
The system achieves a near-linear computational cost in dataset size and model count compared to quadratic cost in na√Øve multi-model evaluation.

This significant reduction in inference cost while maintaining accuracy creates practical viability for real-time, large-scale deployments.

6. Patent-Worthy Combinatorial Approach
While individual components like multi-armed bandits and confidence scoring exist in the literature, the specific combination and sequencing of early rejection, confidence-augmented reward, and input-aware routing applied to LLM arbitration is novel and non-obvious.

The architecture also incorporates dynamic model dropout based on easy example performance in a single/few-pass approach, which is not previously known.



Rethought Workflow for Multi-LLM Model Selection Using Multi-Armed Bandit with Early Dropout
Input
ùëÅ
N candidate LLMs: 
ùëÄ
1
,
ùëÄ
2
,
.
.
.
,
ùëÄ
ùëÅ
M 
1
‚Äã
 ,M 
2
‚Äã
 ,...,M 
N
‚Äã
 

Dataset with 
ùëÄ
M rows/examples: 
ùê∑
=
{
(
ùë•
ùëñ
,
ùë¶
ùëñ
)
}
ùëñ
=
1
ùëÄ
D={(x 
i
‚Äã
 ,y 
i
‚Äã
 )} 
i=1
M
‚Äã
 

Step 1: Initial Dataset Split and Early Performance Monitoring
Split dataset 
ùê∑
D into two parts:

Phase 1: First 20% of data, 
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
D 
init
‚Äã
  (e.g., first 
0.2
√ó
ùëÄ
0.2√óM rows)

Phase 2: Remaining 80%, 
ùê∑
ùëü
ùëí
ùë†
ùë°
D 
rest
‚Äã
 

Step 2: Parallel Model Evaluation on 
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
D 
init
‚Äã
 
Run all 
ùëÅ
N models on 
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
D 
init
‚Äã
  in parallel (or batched to minimize runtime).

Track model performance accuracy 
ùê¥
ùëñ
A 
i
‚Äã
  over 
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
D 
init
‚Äã
  incrementally, i.e., update accuracy after each example or small batch.

Step 3: Early Dropout with Patience
Define a patience parameter 
ùëù
=
3
p=3 (number of consecutive failures allowed).

For each model 
ùëÄ
ùëñ
M 
i
‚Äã
 , monitor performance in sliding windows or per example:

If 
ùëÄ
ùëñ
M 
i
‚Äã
  fails to predict correctly on 
ùëù
p consecutive examples while at least one other model performs correctly on those examples, mark 
ùëÄ
ùëñ
M 
i
‚Äã
  as a candidate for dropout.

Drop 
ùëÄ
ùëñ
M 
i
‚Äã
  only if this failure pattern persists (no recovery) within the first 20% data.

This eliminates clearly underperforming models early, relying on relative performance, not absolute thresholds.

Step 4: Narrowed Down Model Set
After Phase 1, retain models that survived dropout.

If more than 5 models remain, keep top 5 based on accuracy or aggregate performance metrics on 
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
D 
init
‚Äã
 .

Step 5: Multi-Armed Bandit on Remaining Data 
ùê∑
ùëü
ùëí
ùë†
ùë°
D 
rest
‚Äã
 
Initialize bandit values 
ùëÑ
ùëñ
Q 
i
‚Äã
  for each retained model 
ùëÄ
ùëñ
M 
i
‚Äã
 .

For each incoming example 
ùë•
ùë°
x 
t
‚Äã
  in 
ùê∑
ùëü
ùëí
ùë†
ùë°
D 
rest
‚Äã
 :

Select a model 
ùëÄ
ùëñ
M 
i
‚Äã
  using the multi-armed bandit policy (e.g., UCB, Thompson Sampling) balancing exploration-exploitation.

Model 
ùëÄ
ùëñ
M 
i
‚Äã
  predicts 
ùë¶
^
ùë°
y
^
‚Äã
  
t
‚Äã
 .

Reward 
ùëü
ùëñ
=
1
r 
i
‚Äã
 =1 if 
ùë¶
^
ùë°
=
ùë¶
ùë°
y
^
‚Äã
  
t
‚Äã
 =y 
t
‚Äã
 , else 0.

Update 
ùëÑ
ùëñ
Q 
i
‚Äã
  based on reward to improve model selection policy.

Step 6: Optional Router Training (Post Bandit Phase)
Use data from bandit assignments and outcomes to train a router 
ùëÖ
R that predicts best model per input features.

This router can accelerate or replace bandit decisions on new/unseen data.

Step 7: Output
Final best subset of models selected by performance and bandit optimization.

Model value estimates 
ùëÑ
ùëñ
Q 
i
‚Äã
  reflecting per-model utility.

Optional trained router 
ùëÖ
R for input-driven model assignment.

Summary:
Early phase dropout uses relative performance with patience on 20% data.

Patience ensures transient failures don‚Äôt unfairly drop models, but persistent lagging models are pruned.

Final selection uses multi-armed bandit on reduced model pool and remaining data, dynamically optimizing model assignment.

--------
Algorithm: Multi-LLM Selection with Early Dropout and Bandit Optimization
Input:

Models 
ùëÄ
=
{
ùëÄ
1
,
ùëÄ
2
,
.
.
.
,
ùëÄ
ùëÅ
}
M={M 
1
‚Äã
 ,M 
2
‚Äã
 ,...,M 
N
‚Äã
 }

Dataset 
ùê∑
=
{
(
ùë•
ùëñ
,
ùë¶
ùëñ
)
}
ùëñ
=
1
ùëÄ
D={(x 
i
‚Äã
 ,y 
i
‚Äã
 )} 
i=1
M
‚Äã
 

Patience parameter 
ùëù
p (e.g., 3)

Max retained models 
ùëò
k (e.g., 5)

Output:

Selected subset of models 
ùëÄ
ùëì
ùëñ
ùëõ
ùëé
ùëô
M 
final
‚Äã
 

Model quality estimates 
ùëÑ
Q

Optional router 
ùëÖ
R

Procedure:

Split dataset:

ùê∑
ùëñ
ùëõ
ùëñ
ùë°
‚Üê
D 
init
‚Äã
 ‚Üê first 20% of 
ùê∑
D

ùê∑
ùëü
ùëí
ùë†
ùë°
‚Üê
D 
rest
‚Äã
 ‚Üê remaining 80% of 
ùê∑
D

Initialize:

For each model 
ùëÄ
ùëñ
M 
i
‚Äã
 , set:

ùëê
ùëú
ùëõ
ùë†
ùëí
ùëê
ùë¢
ùë°
ùëñ
ùë£
ùëí
_
ùëì
ùëé
ùëñ
ùëô
ùë¢
ùëü
ùëí
ùë†
ùëñ
‚Üê
0
consecutive_failures 
i
‚Äã
 ‚Üê0

ùëë
ùëü
ùëú
ùëù
ùëù
ùëí
ùëë
ùëñ
‚Üê
ùêπ
ùëé
ùëô
ùë†
ùëí
dropped 
i
‚Äã
 ‚ÜêFalse

ùëê
ùëú
ùëü
ùëü
ùëí
ùëê
ùë°
ùëñ
‚Üê
0
correct 
i
‚Äã
 ‚Üê0

ùë°
ùëú
ùë°
ùëé
ùëô
ùëñ
‚Üê
0
total 
i
‚Äã
 ‚Üê0

Early evaluation & dropout:
For each example 
(
ùë•
ùë°
,
ùë¶
ùë°
)
‚àà
ùê∑
ùëñ
ùëõ
ùëñ
ùë°
(x 
t
‚Äã
 ,y 
t
‚Äã
 )‚ààD 
init
‚Äã
 :
¬†¬†a. Collect set 
ùê∂
=
{
}
C={} of models predicting correctly on 
ùë•
ùë°
x 
t
‚Äã
 .
¬†¬†b. For each 
ùëÄ
ùëñ
M 
i
‚Äã
  not dropped:
¬†¬†¬†¬†i. Predict 
ùë¶
^
ùë°
=
ùëÄ
ùëñ
(
ùë•
ùë°
)
y
^
‚Äã
  
t
‚Äã
 =M 
i
‚Äã
 (x 
t
‚Äã
 )
¬†¬†¬†¬†ii. Update 
ùë°
ùëú
ùë°
ùëé
ùëô
ùëñ
‚Üê
ùë°
ùëú
ùë°
ùëé
ùëô
ùëñ
+
1
total 
i
‚Äã
 ‚Üêtotal 
i
‚Äã
 +1
¬†¬†¬†¬†iii. If 
ùë¶
^
ùë°
=
ùë¶
ùë°
y
^
‚Äã
  
t
‚Äã
 =y 
t
‚Äã
 , then
¬†¬†¬†¬†¬†¬†- 
ùëê
ùëú
ùëü
ùëü
ùëí
ùëê
ùë°
ùëñ
‚Üê
ùëê
ùëú
ùëü
ùëü
ùëí
ùëê
ùë°
ùëñ
+
1
correct 
i
‚Äã
 ‚Üêcorrect 
i
‚Äã
 +1
¬†¬†¬†¬†¬†¬†- 
ùëê
ùëú
ùëõ
ùë†
ùëí
ùëê
ùë¢
ùë°
ùëñ
ùë£
ùëí
_
ùëì
ùëé
ùëñ
ùëô
ùë¢
ùëü
ùëí
ùë†
ùëñ
‚Üê
0
consecutive_failures 
i
‚Äã
 ‚Üê0
¬†¬†¬†¬†¬†¬†- Add 
ùëÄ
ùëñ
M 
i
‚Äã
  to 
ùê∂
C
¬†¬†¬†¬†Else
¬†¬†¬†¬†¬†¬†- 
ùëê
ùëú
ùëõ
ùë†
ùëí
ùëê
ùë¢
ùë°
ùëñ
ùë£
ùëí
_
ùëì
ùëé
ùëñ
ùëô
ùë¢
ùëü
ùëí
ùë†
ùëñ
‚Üê
ùëê
ùëú
ùëõ
ùë†
ùëí
ùëê
ùë¢
ùë°
ùëñ
ùë£
ùëí
_
ùëì
ùëé
ùëñ
ùëô
ùë¢
ùëü
ùëí
ùë†
ùëñ
+
1
consecutive_failures 
i
‚Äã
 ‚Üêconsecutive_failures 
i
‚Äã
 +1
¬†¬†c. For each 
ùëÄ
ùëñ
M 
i
‚Äã
  not dropped:
¬†¬†¬†¬†i. If 
ùëê
ùëú
ùëõ
ùë†
ùëí
ùëê
ùë¢
ùë°
ùëñ
ùë£
ùëí
_
ùëì
ùëé
ùëñ
ùëô
ùë¢
ùëü
ùëí
ùë†
ùëñ
‚â•
ùëù
consecutive_failures 
i
‚Äã
 ‚â•p AND 
ùëÄ
ùëñ
‚àâ
ùê∂
M 
i
‚Äã
 ‚àà
/
C AND 
‚à£
ùê∂
‚à£
>
0
‚à£C‚à£>0 then
¬†¬†¬†¬†¬†¬†Set 
ùëë
ùëü
ùëú
ùëù
ùëù
ùëí
ùëë
ùëñ
‚Üê
ùëá
ùëü
ùë¢
ùëí
dropped 
i
‚Äã
 ‚ÜêTrue

Select survivors:

Let 
ùëÜ
=
{
ùëÄ
ùëñ
‚à£
ùëë
ùëü
ùëú
ùëù
ùëù
ùëí
ùëë
ùëñ
=
ùêπ
ùëé
ùëô
ùë†
ùëí
}
S={M 
i
‚Äã
 ‚à£dropped 
i
‚Äã
 =False}

If 
‚à£
ùëÜ
‚à£
>
ùëò
‚à£S‚à£>k, keep top 
ùëò
k models with highest 
ùëê
ùëú
ùëü
ùëü
ùëí
ùëê
ùë°
ùëñ
ùë°
ùëú
ùë°
ùëé
ùëô
ùëñ
total 
i
‚Äã
 
correct 
i
‚Äã
 
‚Äã
 

Initialize bandit:

For each 
ùëÄ
ùëñ
‚àà
ùëÜ
M 
i
‚Äã
 ‚ààS, set 
ùëÑ
ùëñ
‚Üê
0
Q 
i
‚Äã
 ‚Üê0, 
ùëÅ
ùëñ
‚Üê
0
N 
i
‚Äã
 ‚Üê0

Bandit-based selection on 
ùê∑
ùëü
ùëí
ùë†
ùë°
D 
rest
‚Äã
 :
For each 
(
ùë•
ùë°
,
ùë¶
ùë°
)
‚àà
ùê∑
ùëü
ùëí
ùë†
ùë°
(x 
t
‚Äã
 ,y 
t
‚Äã
 )‚ààD 
rest
‚Äã
 :
¬†¬†a. Select 
ùëÄ
ùëó
‚àà
ùëÜ
M 
j
‚Äã
 ‚ààS via bandit policy (e.g., UCB)
¬†¬†b. Predict 
ùë¶
^
ùë°
=
ùëÄ
ùëó
(
ùë•
ùë°
)
y
^
‚Äã
  
t
‚Äã
 =M 
j
‚Äã
 (x 
t
‚Äã
 )
¬†¬†c. Compute reward 
ùëü
=
1
r=1 if 
ùë¶
^
ùë°
=
ùë¶
ùë°
y
^
‚Äã
  
t
‚Äã
 =y 
t
‚Äã
  else 0
¬†¬†d. Update 
ùëÅ
ùëó
‚Üê
ùëÅ
ùëó
+
1
N 
j
‚Äã
 ‚ÜêN 
j
‚Äã
 +1
¬†¬†e. Update 
ùëÑ
ùëó
‚Üê
ùëÑ
ùëó
+
1
ùëÅ
ùëó
(
ùëü
‚àí
ùëÑ
ùëó
)
Q 
j
‚Äã
 ‚ÜêQ 
j
‚Äã
 + 
N 
j
‚Äã
 
1
‚Äã
 (r‚àíQ 
j
‚Äã
 )

Optional router training:

Train router 
ùëÖ
R to map input 
ùë•
x to best 
ùëÄ
ùëñ
M 
i
‚Äã
  using accumulated data

Return:

ùëÄ
ùëì
ùëñ
ùëõ
ùëé
ùëô
=
ùëÜ
M 
final
‚Äã
 =S

Quality estimates 
ùëÑ
Q

Optional 
ùëÖ
R
